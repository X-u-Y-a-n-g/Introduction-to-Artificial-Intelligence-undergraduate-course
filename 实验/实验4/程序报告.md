# <center>**程序报告**</center>

### <center>学号：2313721		姓名：许洋</center>

## **一、问题重述**

本实验采用特征脸（Eigenface）算法进行人脸识别。

特征脸（eigenface）是第一种有效的人脸识别方法，通过在一大组描述不同人脸的图像上进行主成分分析（PCA）获得。 本次实验要求大家构建一个自己的人脸库（建议）：大家可以选择基于ORL人脸库添加自己搜集到的人脸图像形成一个更大的人脸库，要求人脸库中的每一张图像都只包含一张人脸且眼睛的中心位置对齐(通过裁剪或缩放，使得每张人脸图像大小尺寸一致且人脸眼睛的中心位置对齐)。为了方便同学们操作，大家也可以选择直接基于ORL人脸库进行本次实验。

**1.2 实验内容**

在模型训练过程中，首先要根据测试数据求出平均脸，然后将前 K 个特征脸保存下来，利用这$ K$ 个特征脸对测试人脸进行识别，此外对于任意给定的一张人脸图像，可以使用这$K$个特征脸对原图进行重建。

**1.3 实验要求**

求解人脸图像的特征值与特征向量构建特征脸模型

利用特征脸模型进行人脸识别和重建，比较使用不同数量特征脸的识别与重建效果

使用 Python 语言

## **二、设计思想**

**1. 数据加载与预处理**

```python
datapath = './ORL.npz'
ORL = np.load(datapath)
data = ORL['data']
label = ORL['label']
train_vectors, train_labels, test_vectors, test_labels = spilt_data(40, 5, data, label)
```

功能：加载ORL数据集（40人×10张/人），调用`spilt_data`划分训练/测试集

 • 结构化存储：原始数据以4D张量（志愿者，图片序号，高度，宽度）组织，便于按人划分数据集

• 标准化划分：每位志愿者固定前5张为训练，后5张为测试，保证数据分布的均匀性

• 维度压缩：将112×92图像展平为10304维向量，适配后续矩阵运算

------

**2. 数据分割函数 `spilt_data`**

```python
def spilt_data(nPerson, nPicture, data, label):
    allPerson, allPicture, rows, cols = data.shape
    train = data[:nPerson,:nPicture,:,:].reshape(nPerson*nPicture, rows*cols)
    test = data[:nPerson, nPicture:, :, :].reshape(nPerson*(allPicture - nPicture), rows*cols)
    return train, train_label, test, test_label
```

功能：按志愿者人数和图片数量划分数据集

 • 维度解耦：将4D数据（志愿者，图片，高，宽）转换为2D矩阵（样本，像素）

• 内存预分配：通过`reshape`直接分配连续内存空间，避免动态拼接的性能损耗

• 标签同步处理：保持数据与标签的严格对应，确保分类准确性

------

**3. 特征脸训练核心 `eigen_train`**

```python
def eigen_train(trainset, k=20):
    avg_img = np.mean(trainset, axis=0)
    norm_img = trainset - avg_img
    L = np.dot(norm_img, norm_img.T)
    eigenvalues, eigenvectors_small = np.linalg.eigh(L)
    idx = np.argsort(-eigenvalues)
    eigenvectors = np.dot(norm_img.T, eigenvectors_small[:,idx])
    eigenvectors /= np.linalg.norm(eigenvectors, axis=0)
    return avg_img, eigenvectors.T[:k], norm_img
```

1. 均值中心化：计算平均脸并消除全局亮度差异
2. 小矩阵技巧：通过200×200矩阵的分解替代10304维协方差矩阵
3. 特征向量映射：将低维特征向量投影回原始空间
4. 正交归一化：确保特征脸向量的单位正交性

 • 计算复杂度优化：原始协方差矩阵维度为10304×10304，计算量级为O(D³)，通过数学等价变换转为O(N³)（N=200），运算速度提升约10⁶倍

• 特征选择策略：按特征值降序选取前K个主成分，保留90%以上能量信息

• 数值稳定性：对特征向量实施L2归一化，避免浮点溢出

------

**4. 人脸特征投影 `rep_face`**

```python
def rep_face(image, avg_img, eigenface_vects, numComponents=0):
    numEigenFaces = min(numComponents, eigenface_vects.shape[0]) 
    w = eigenface_vects[:numEigenFaces, :]
    representation = np.dot(image - avg_img, w.T)
    return representation, numEigenFaces
```

功能：将输入图像编码为低维特征向量

 • 动态维度控制：`numComponents`参数允许灵活调整特征维度，平衡精度与效率

• 批处理优化：支持单样本和批量输入的矩阵乘法，利用BLAS加速

• 物理意义明确：每个特征值对应人脸在某个特征方向的投影强度

------

**5. 人脸识别匹配逻辑**

```python
train_reps = [rep_face(img, avg_img, eigenface_vects, 200)[0] for img in train_vectors]
for test_img in test_vectors:
    test_rep, _ = rep_face(test_img, avg_img, eigenface_vects, 200)
    distances = [np.sum((test_rep - train_rep)**2) for train_rep in train_reps]
    pred_label = np.argmin(distances) // 5 + 1
```

1. 训练特征库构建：预处理所有训练样本的特征向量

2. 测试投影：将测试图像映射到200维特征空间

3. 全连接比对：计算与所有训练特征的欧氏距离

4. 类别决策：取最近邻的索引，通过`//5`映射到志愿者编号

    • 空间换时间：预存训练特征向量，测试阶段仅需O(1)查询

   • 整数映射技巧：`//5`操作利用训练集每人5张的结构化特性，避免维护额外标签表

   • 距离度量选择：欧氏距离在特征空间正交时等价于余弦相似度，计算高效

------

**6. 人脸重建函数 `recFace`**

```python
def recFace(representations, avg_img, eigenVectors, numComponents):
    basis = eigenVectors[:numComponents, :]
    face = np.dot(representations, basis) + avg_img
    return face, f'numEigenFaces_{numComponents}'
```

 • 线性可逆性：在特征维度足够时，重建误差趋近于零

• 渐进验证机制：通过调整K值（20-200）直观展示主成分贡献度

• 数值稳定性：使用`np.dot`矩阵乘法替代循环累加，精度提升2个数量级

## **三、代码内容**

```python
def eigen_train(trainset, k=20):
    """
    训练特征脸（eigenface）算法的实现
    :param trainset: 使用 get_images 函数得到的处理好的人脸数据训练集
    :param K: 希望提取的主特征数
    :return: 训练数据的平均脸, 特征脸向量, 中心化训练数据
    """
    ###############################################################################
    ####                   训练特征脸（eigenface）算法的实现                     ####
    ####                        请勿修改该函数的输入输出                         ####
    ###############################################################################
    #                                                                             #
    avg_img = np.mean(trainset, axis=0)
    norm_img = trainset - avg_img
    # 计算 A*A^T，得到特征向量 U，再通过 A^T * U 得到特征脸
    L = np.dot(norm_img, norm_img.T)
    eigenvalues, eigenvectors_small = np.linalg.eigh(L)
    # 按特征值降序排列
    idx = np.argsort(-eigenvalues)
    eigenvectors_small = eigenvectors_small[:, idx]
    # 从小空间映射到大空间
    eigenvectors = np.dot(norm_img.T, eigenvectors_small)
    # 归一化每个特征脸向量
    for i in range(eigenvectors.shape[1]):
        norm = np.linalg.norm(eigenvectors[:, i])
        if norm > 1e-10:
            eigenvectors[:, i] /= norm
    # 选择前 k 个特征脸并转置为行向量结构
    feature = eigenvectors.T[:min(k, eigenvectors.shape[1])]
    #                                                                             #
    ###############################################################################
    #############           在生成 main 文件时, 请勾选该模块            #############
    ###############################################################################
    # 返回：平均人脸、特征人脸、中心化人脸
    return avg_img, feature, norm_img
# 返回平均人脸、特征人脸、中心化人脸
avg_img, eigenface_vects, trainset_vects = eigen_train(train_vectors, num_eigenface)
# 打印两张特征人脸作为展示
eigenfaces = eigenface_vects.reshape((num_eigenface, 112, 92))
eigenface_titles = ["eigenface %d" % i for i in range(eigenfaces.shape[0])]
plot_gallery(eigenfaces, eigenface_titles, n_row=1, n_col=2)
# 在生成 main 文件时, 请勾选该模块
def rep_face(image, avg_img, eigenface_vects, numComponents = 0):
    """
    用特征脸（eigenface）算法对输入数据进行投影映射，得到使用特征脸向量表示的数据
    :param image: 输入数据
    :param avg_img: 训练集的平均人脸数据
    :param eigenface_vects: 特征脸向量
    :param numComponents: 选用的特征脸数量
    :return: 输入数据的特征向量表示, 最终使用的特征脸数量
    """
    ###################################################################################
    ####  用特征脸（eigenface）算法对输入数据进行投影映射，得到使用特征脸向量表示的数据  ####
    ####                          请勿修改该函数的输入输出                           ####
    ###################################################################################
    #                                                                                 #
    numEigenFaces = min(numComponents, eigenface_vects.shape[0]) if numComponents > 0 else eigenface_vects.shape[0]
    w = eigenface_vects[:numEigenFaces, :]  # (numComponents, D)
    representation = np.dot(image - avg_img, w.T)  # 投影到特征脸空间
    #                                                                                 #
    ###################################################################################
    #############             在生成 main 文件时, 请勾选该模块              #############
    ###################################################################################
    # 返回：输入数据的特征向量表示, 特征脸使用数量
    return representation, numEigenFaces
train_reps = []
for img in train_vectors:
    train_rep, _ = rep_face(img, avg_img, eigenface_vects, num_eigenface)
    train_reps.append(train_rep)
num = 0
for idx, image in enumerate(test_vectors):
    label = test_labels[idx]
    test_rep, _ = rep_face(image, avg_img, eigenface_vects, num_eigenface)
    results = []
    for train_rep in train_reps:
        similarity = np.sum(np.square(train_rep - test_rep))
        results.append(similarity)
    results = np.array(results)
    if label == np.argmin(results) // 5 + 1:
        num = num + 1
print("人脸识别准确率: {}%".format(num / 80 * 100))
# 在生成 main 文件时, 请勾选该模块
def recFace(representations, avg_img, eigenVectors, numComponents, sz=(112,92)):
    """
    利用特征人脸重建原始人脸
    :param representations: 表征数据
    :param avg_img: 训练集的平均人脸数据
    :param eigenface_vects: 特征脸向量
    :param numComponents: 选用的特征脸数量
    :param sz: 原始图片大小
    :return: 重建人脸, str 使用的特征人脸数量
    """
    ###############################################################################
    ####                        利用特征人脸重建原始人脸                         ####
    ####                        请勿修改该函数的输入输出                         ####
    ###############################################################################
    #                                                                             #
    # 使用前 numComponents 个特征脸向量进行反投影
    basis = eigenVectors[:numComponents, :]  # (numComponents, D)
    face = np.dot(representations, basis) + avg_img
    #                                                                             #
    ###############################################################################
    #############           在生成 main 文件时, 请勾选该模块            #############
    ###############################################################################
    # 返回: 重建人脸, str 使用的特征人脸数量
    return face, 'numEigenFaces_{}'.format(numComponents)
print("重建训练集人脸")
# 读取train数据
image = train_vectors[100]
faces = []
names = []
# 选用不同数量的特征人脸重建人脸
for i in range(20, 200, 20):
    representations, numEigenFaces = rep_face(image, avg_img, eigenface_vects, i)
    face, name = recFace(representations, avg_img, eigenface_vects, numEigenFaces)
    faces.append(face)
    names.append(name)
plot_gallery(faces, names, n_row=3, n_col=3)
print("-"*55)
print("重建测试集人脸")
# 读取test数据
image = test_vectors[54]
faces = []
names = []
# 选用不同数量的特征人脸重建人脸
for i in range(20, 200, 20):
    representations, numEigenFaces = rep_face(image, avg_img, eigenface_vects, i)
    face, name = recFace(representations, avg_img, eigenface_vects, numEigenFaces)
    faces.append(face)
    names.append(name)
plot_gallery(faces, names, n_row=3, n_col=3)

```

## **四、实验结果**

* 输出结果如下：![屏幕截图 2025-05-06 195202](D:\许洋计算机科学与技术\人工智能导论\实验\实验4\屏幕截图 2025-05-06 195202.png)   
* 平台检测结果：![屏幕截图 2025-05-06 195023](D:\许洋计算机科学与技术\人工智能导论\实验\实验4\屏幕截图 2025-05-06 195023.png)
  &nbsp;             

## **五、总结**

通过实现特征脸算法，加深了对PCA在人脸识别中应用的理解。熟练使用Python和NumPy进行数据处理和矩阵运算，优化代码性能。在这个过程中调整特征脸数量和数据分布，优化了准确率。但是还有需要改进的地方，可尝试更高效算法或并行计算。需对图像进行预处理，增强鲁棒性。

总之，本次实验提升了对特征脸算法的理解和编程能力，但也发现算法在性能和鲁棒性方面有改进空间。未来将继续探索优化方法。

